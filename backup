#!/bin/bash
# author : lordpax
# backup v3.0
# Petit script de backup

export TEXTDOMAIN="backup"

pass=""
encrypt=0
tmp_folders=""
backup_folders=""
backup_dest="."
log=0
logFile=""
version="v3.0"
archive_name=""
verbose=0
nbToSave=0
restore=0

# echo_deb <msg>
function echo_log() {
    if [ "A$1" != "A" ] && [ "A$logFile" != "A" ]; then
        local date=$(date "+%Y-%m-%d %H:%M:%S")
        echo -e "$date : $1" >> $logFile
    fi
}

# echo_err <msg>
function echo_err() {
    if [ "A$1" != "A" ]; then
        if [ $log -eq 1 ]; then
            echo_log "ERROR : $1"
        else
            echo -e "\e[31mERROR :\e[0m $1" > /dev/stderr
        fi
    fi
}

# echo_out <msg>
function echo_out() {
    if [ "A$1" != "A" ]; then
        if [ $log -eq 1 ]; then
            echo_log "$1" 
        else
            echo -e "$1"
        fi
    fi
}

function helpFunc() {
    echo_out $"Usage : $0 [option]

Option :
-h or --help ........................... Show help
-v or --version ........................ Show version
-V or --verbose ........................ Verbose mode
-f \"<dir1> [dirN]\" ..................... Source folder
-c <config> ............................ File which contain source folders name
-r <backupDir> ......................... Restore backup from backupDir to outputDir
-g <config> <branch> ................... Push file into a git repo (soon)
-o <outputDir> ......................... Destination folder
-p <pass> .............................. Pass phrase encrypt
-d <pass> .............................. Pass phrase decrypt (soon)
-l <logFile> ........................... Log file
-n <name> .............................. Name of output archive (automatically add .tar.gz)
-s <nbToSave> .......................... Save nbToSave backup and delete other

Example :
backup -f \"dir_1 dir_2 dir_3\" -o dest_folder
backup -c config.txt -o dest_folder
backup -f \"dir_1 dir_2 dir_3\" -o dest_folder -l logfile.log
backup -f \"dir_1 dir_2 dir_3\" -o dest_folder -p passphrase
backup -r /path/to/backup/ -o path/to/extract -n name
"

    exit 0
}

function verification() {
    if [ "A$tmp_folders" != "A" ]; then
        for file in $tmp_folders; do
            if [ -d $file ] || [ -f $file ]; then
                backup_folders="$backup_folders $file"
            else
                echo_err $"Source \"$file\" folder does not exist"
            fi
        done
    else
        echo_err $"Source folder is missing"
        exit 1
    fi

    if [ "A$backup_dest" != "A" ]; then
        if [ ! -d $backup_dest ]; then
            echo_err $"Destination \"$backup_dest\" folder does not exist"
            exit 1
        fi
    else
        echo_err $"Destination folder is missing"
        exit 1
    fi

    if [ $encrypt -eq 1 ] && [ "A$pass" = "A" ]; then
        echo_err $"Passphrase is missing"
        exit 1
    fi

    if [ $log -eq 1 ] && [ "A$logFile" = "A" ]; then
        log=0
        echo_err $"Log file is missing"
        exit 1
    fi
}

# readConfig <config>
function readConfig() {
    if [ "A$1" != "A" ]; then
        while read line; do
            tmp_folders="$tmp_folders $line"
        done < $1
    fi
}

function encryptFile() {
    echo_out $"Encryption of $backup_dest/$archive_name"
    if ! gpg --batch --passphrase $pass -c $backup_dest/$archive_name; then
        echo_err $"Something wrong with encrytion"
        exit 1
    fi
    rm $backup_dest/$archive_name
    echo_out $"Encryption $backup_dest/$archive_name.gpg end"
}

# TODO : decryptFile
# function decryptFile() {
#     local name=$([ "A$archive_name" != "A" ] && echo "$archive_name" || echo "backup_${hostname}")
#     local archive_date=$(ls $backup_folders | grep $name | cut -d '.' -f 2 | sort -r | head -1)
#     local out=$(([ $log -eq 1 ] || [ $verbose -eq 0 ]) && echo /dev/null || echo /dev/stdout)

#     echo_out $"Decryption of $backup_folders/$archive_name.gpg"
#     if ! gpg --batch --passphrase $pass -d $backup_folders/$archive_name
# }

function compressFile() {
    local date=$(date +%Y-%m-%d)
    # local hostname=$(hostname -s)
    local hostname=$(hostnamectl hostname)
    local out=$(([ $log -eq 1 ] || [ $verbose -eq 0 ]) && echo /dev/null || echo /dev/stdout)
    
    local name=$([ "A$archive_name" != "A" ] && echo "${archive_name}.${date}.tar.gz" || echo "backup_${hostname}.${date}.tar.gz")

    echo_out $"Compress of :"
    for file in $backup_folders; do
        echo_out "  -> $file"
    done

    echo_out $"Backup $backup_dest/$name in progress ..."
    if ! tar czfv $backup_dest/$name $backup_folders &> $out; then
        echo_err $"Something wrong with compression"
        exit 1
    fi

    echo_out $"Backup $backup_dest/$name end"
}

# delete <nbToSave>
# conserve les nbToSave les plus rÃ©centes et supprime les autres
function delete() {
    if [ "A$1" != "A" ]; then
        local date=$(date +%Y-%m-%d)
        local hostname=$(hostname -s)
        local name=$([ "A$archive_name" != "A" ] && echo "$archive_name" || echo "backup_${hostname}")
        local nbFile=$(ls $backup_dest | grep $name | wc -l)
        local nbToDel=$(( nbFile - $1 ))

        if [ $nbToDel -gt 0 ]; then 
            local archive_date=$(ls $backup_dest | grep $name | cut -d '.' -f 2 | sort -r | tail -$nbToDel)

            echo_out "Deleting $nbToDel old backup : "
            
            for elem in $archive_date; do
                echo_out "  -> Deleting $backup_dest/${name}.${elem}.tar.gz ..."
                rm $backup_dest/${name}.${elem}.tar.gz
            done
        fi
    fi
}

# restoreFile 
function restoreFile() {
    local name=$([ "A$archive_name" != "A" ] && echo "$archive_name" || echo "backup_${hostname}")
    local archive_date=$(ls $backup_folders | grep $name | cut -d '.' -f 2 | sort -r | head -1)
    local out=$(([ $log -eq 1 ] || [ $verbose -eq 0 ]) && echo /dev/null || echo /dev/stdout)

    if [ "A$archive_date" == "A" ]; then
        echo_err $"No backup found"
        exit 1
    fi
    
    echo_out $"Restoration of $backup_folders/${name}.${archive_date}.tar.gz to $backup_dest"
    if ! tar xfz $backup_folders/${name}.${archive_date}.tar.gz -C $backup_dest &> $out; then
        echo_err $"Something wrong with restoration"
        exit 1
    fi
}

# TODO : gitPushFile
# function gitPushFile() {
# }

if [ $# -ge 1 ]; then
    for i in $(seq 1 $#); do
        if [ "$1" == "--help" ] || [ "$1" == "-h" ]; then 
            helpFunc
        elif [ "$1" == "--verbose" ] || [ "$1" == "-V" ]; then 
            verbose=1
        elif [ "$1" == "--version" ] || [ "$1" == "-v" ]; then 
            echo_out $version
            exit 0
        elif [ "$1" == "-f" ]; then
            shift
            tmp_folders=$1
        elif [ "$1" == "-r" ]; then
            shift
            restore=1
            tmp_folders=$1
        elif [ "$1" == "-o" ]; then
            shift
            backup_dest=$1
        elif [ "$1" == "-c" ]; then
            shift
            readConfig $1
        elif [ "$1" == "-l" ]; then
            shift
            log=1
            logFile=$1
        elif [ "$1" == "-p" ]; then
            shift
            encrypt=1
            pass=$1
        elif [ "$1" == "-n" ]; then
            shift
            archive_name=$1
        elif [ "$1" == "-s" ]; then
            shift
            nbToSave=$1
        fi
        shift
    done
fi

verification
[ $restore -eq 0 ] && compressFile || restoreFile
[ $encrypt -eq 1 ] && encryptFile
[ $nbToSave -gt 0 ] && delete $nbToSave